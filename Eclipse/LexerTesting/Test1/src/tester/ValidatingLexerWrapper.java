package tester;

import lang.IElementType;
import lang.lexer.Lexer;
import lang.lexer.LexerPosition;

/**
 * This class verifies that delegate lexer generates a continuous sequence of tokens (without gaps), and that it
 * does not stall during iteration (generating empty tokens for the same offset continuously).
 */
final class ValidatingLexerWrapper extends Lexer {
  private final Lexer myDelegate;
  private int myLastStartOffset;
  private int myLastEndOffset;
  private int myLastState;
  private IElementType myLastTokenType;
  private boolean myLastValuesActual;

  ValidatingLexerWrapper(Lexer delegate) { myDelegate = delegate;}

  @Override
  public CharSequence getTokenSequence() {
    return myDelegate.getTokenSequence();
  }

  @Override
  public String getTokenText() {
    return myDelegate.getTokenText();
  }

  @Override
  public void start(CharSequence buffer, int startOffset, int endOffset, int initialState) {
    myDelegate.start(buffer, startOffset, endOffset, initialState);
    myLastValuesActual = false;
  }

  @Override
  public int getState() {
    return myLastValuesActual ? myLastState : myDelegate.getState();
  }

  @Override
  public IElementType getTokenType() {
    if (!myLastValuesActual) {
      myLastTokenType = myDelegate.getTokenType();
      if (myLastTokenType != null) {
        myLastStartOffset = myDelegate.getTokenStart();
        myLastEndOffset = myDelegate.getTokenEnd();
        myLastState = myDelegate.getState();
      }
      myLastValuesActual = true;
    }
    return myLastTokenType;
  }

  @Override
  public int getTokenStart() {
    return myLastValuesActual ? myLastStartOffset : myDelegate.getTokenStart();
  }

  @Override
  public int getTokenEnd() {
    return myLastValuesActual ? myLastEndOffset : myDelegate.getTokenEnd();
  }

  @Override
  public void advance() {
    myDelegate.advance();

    int prevStart = 0;
    int prevEnd = 0;
    int prevState = 0;
    IElementType prevType = null;
    if (myLastValuesActual) {
      prevStart = myLastStartOffset;
      prevEnd = myLastEndOffset;
      prevState = myLastState;
      prevType = myLastTokenType;
    }

    myLastValuesActual = false;
    getTokenType(); // cache values

    if (prevType != null && myLastTokenType != null) {
      if (myLastStartOffset > myLastEndOffset) {
        throwException("Incorrect token offsets returned by lexer");
      }
      if (myLastStartOffset != prevEnd) {
	    	IO.println("\nValidatingLexerWrapper.advance: =========== ERROR ==========");
    	  IO.println("ValidatingLexerWrapper.advance: myLastStartOffset="+myLastStartOffset);
    	  IO.println("ValidatingLexerWrapper.advance: prevEnd="+prevEnd);
    	  throw new RuntimeException("Discontinuous sequence of tokens is generated by lexer");
//      throwException("Discontinuous sequence of tokens is generated by lexer");
      }
      if (myLastEndOffset == myLastStartOffset && prevEnd == prevStart && myLastState == prevState && myLastTokenType == prevType) {
        throwException("Lexer is not progressing after calling advance()");
      }
    }
  }

  private String buildDiagnosticMessage(String message) {
    return message +
           "; delegateClass=" + myDelegate.getClass().getCanonicalName() +
           "; delegate=" + myDelegate +
           "; lastTokenType=" + myLastTokenType +
           "; lastStartOffset=" + myLastStartOffset +
           "; lastEndOffset=" + myLastEndOffset +
           "; lastState=" + myLastState;
  }

  @Override
  public LexerPosition getCurrentPosition() {
    return myDelegate.getCurrentPosition();
  }

  @Override
  public void restore(LexerPosition position) {
    myDelegate.restore(position);
    myLastValuesActual = false;
  }

  @Override
  public CharSequence getBufferSequence() {
    return myDelegate.getBufferSequence();
  }

  @Override
  public int getBufferEnd() {
    return myDelegate.getBufferEnd();
  }

  private void throwException(String message) {
//    Class<? extends Lexer> lexerClass = myDelegate.getClass();
//    boolean isFlexAdapter = lexerClass == FlexAdapter.class;
//    throw PluginException.createByClass(
//      buildDiagnosticMessage(message) + ": " + (isFlexAdapter ? myDelegate.toString() : lexerClass.getName()),
//                                        null,
//                                        isFlexAdapter ? ((FlexAdapter)myDelegate).getFlex().getClass() : lexerClass);
	  throw new RuntimeException("ValidatingLexerWrapper.throwException: "+message);
  }
}
